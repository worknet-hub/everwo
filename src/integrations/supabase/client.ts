// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// IMPORTANT: Set these in your .env.local file at the project root:
// VITE_SUPABASE_URL=your-supabase-url
// VITE_SUPABASE_ANON_KEY=your-supabase-anon-key
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Validate environment variables
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error('Missing Supabase environment variables:');
  console.error('VITE_SUPABASE_URL:', SUPABASE_URL ? 'Set' : 'Missing');
  console.error('VITE_SUPABASE_ANON_KEY:', SUPABASE_PUBLISHABLE_KEY ? 'Set' : 'Missing');
  throw new Error('Missing required Supabase environment variables. Please check your .env.local file.');
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
  global: {
    headers: {
      'X-Client-Info': 'everwo-app',
      'Accept': 'application/json',
      // 'Content-Type': 'application/json', // Removed to fix media upload errors
      'Cache-Control': 'no-cache',
    },
  },
});

// Add connection test
export const testSupabaseConnection = async () => {
  try {
    console.log('Testing Supabase connection...');
    const { data, error } = await supabase.from('profiles').select('count').limit(1);
    if (error) {
      console.error('Supabase connection test failed:', error);
      return false;
    }
    console.log('Supabase connection test successful');
    return true;
  } catch (error) {
    console.error('Supabase connection test error:', error);
    return false;
  }
};

// Test if browser extensions are interfering
export const testBrowserExtensions = async () => {
  try {
    console.log('Testing for browser extension interference...');
    
    // Test direct fetch to Supabase
    const response = await fetch(`${SUPABASE_URL}/rest/v1/profiles?select=count&limit=1`, {
      method: 'GET',
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
    });
    
    console.log('Direct fetch response status:', response.status);
    
    if (response.status === 406) {
      console.warn('Browser extensions are likely interfering with requests');
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Browser extension test error:', error);
    return false;
  }
};

// Test likes count triggers
export const testLikesCountTriggers = async () => {
  try {
    console.log('Testing likes count triggers...');
    
    // First, get a thought to test with
    const { data: thoughts, error: thoughtsError } = await supabase
      .from('thoughts')
      .select('id, likes_count')
      .limit(1);
    
    if (thoughtsError || !thoughts || thoughts.length === 0) {
      console.error('No thoughts found for testing');
      return false;
    }
    
    const testThought = thoughts[0];
    console.log('Testing with thought:', testThought.id, 'current likes:', testThought.likes_count);
    
    // Test adding a like
    const { error: insertError } = await supabase
      .from('thought_likes')
      .insert({
        thought_id: testThought.id,
        user_id: '00000000-0000-0000-0000-000000000000'
      });
    
    if (insertError) {
      console.error('Error inserting test like:', insertError);
      return false;
    }
    
    // Check if likes_count increased
    const { data: updatedThought, error: checkError } = await supabase
      .from('thoughts')
      .select('likes_count')
      .eq('id', testThought.id)
      .single();
    
    if (checkError) {
      console.error('Error checking updated thought:', checkError);
      return false;
    }
    
    console.log('Likes count after insert:', updatedThought.likes_count);
    
    // Clean up - remove the test like
    await supabase
      .from('thought_likes')
      .delete()
      .eq('thought_id', testThought.id)
      .eq('user_id', '00000000-0000-0000-0000-000000000000');
    
    return true;
  } catch (error) {
    console.error('Likes count trigger test error:', error);
    return false;
  }
};

// Enhanced error handling for 406 errors
export const handleSupabaseError = (error: any, operation: string) => {
  if (error?.status === 406) {
    console.warn(`406 error in ${operation}. This might be caused by browser extensions. Retrying...`);
    return true; // Indicate retry should be attempted
  }
  return false;
};

// Retry wrapper for Supabase operations
export const withRetry = async <T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  operationName: string = 'operation'
): Promise<T> => {
  let lastError: any;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      if (handleSupabaseError(error, operationName)) {
        console.log(`Retrying ${operationName} (attempt ${attempt}/${maxRetries})`);
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        continue;
      }
      
      // If it's not a 406 error, don't retry
      throw error;
    }
  }
  
  throw lastError;
};